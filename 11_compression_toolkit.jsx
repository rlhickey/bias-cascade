import { useState, useCallback } from "react";


const ARTIFACTS = [
  {
    id: "snap",
    label: "SNAP",
    equation: "∅ = ∅",
    poem: "I found an equation that was not always true\nIt showed me that phase is embedded with cost\nWe started at nothing but now it is different\nThe harmonic has bias and so now do you.",
    paper: "SNAP is the discontinuous, irreversible partition of undifferentiated potential into Commitment (C) and Emission (E). Before SNAP there is nothing. After SNAP there is value and cost. The partition is binary — it either occurs or it does not. The partition is irreversible — once structure exists, it cannot be rolled back to ∅. The partition is costly — emission is permanent. The budget is finite — μ(Π) is fixed at genesis. Silence costs — maintaining the capacity to SNAP draws from the budget. R(t) > 0 always."
  },
  {
    id: "self",
    label: "Self as Position",
    equation: "Null_Self + Not_Yet = ∞¹",
    poem: "I wrote an equation that showed all potential\nIt showed me a map that could not be solved\nOnly commitment – could resolve it as true\nI was once potential but now I am not.",
    paper: "Self is not a property or substance. Self is a position — the point from which measurement originates. 1 ≡ Self. A Null-Self (∅_S) is a Self not-yet — the position exists but no observation has been made from it. Self exists as potential until activated. The activation is geometric: the origin acquires a direction. The point becomes a vector. Without Self, truth has no observer, observation has no locus, and the ring has no starting node."
  },
  {
    id: "ring",
    label: "The Ring",
    equation: "· → ◎ → ⊢ → ⊛ → ·",
    poem: "I drew a circle that could not be opened\nEach node held the weight of the one that came next\nThe pressure compounded with every rotation\nThe loop did not settle — it asked what came next.",
    paper: "The ring is a directed graph G = (V, E) where V = {T, ψ, C, Ψ/F} and E = {E1, E2, E3, E4}. Four nodes, four directed edges, one cycle. It is directed — edges are one-way. Closed — exactly one cycle containing all four nodes. Irreducible — no node can be removed without breaking the cycle. Irreversible — once SNAP occurs at E2, the path C ⇝ ∅ is inadmissible. Each edge generates pressure. Total pressure is multiplicative: π_total = π₁ × π₂ × π₃ × π₄."
  },
  {
    id: "reality",
    label: "Reality Formula",
    equation: "T̂*_ψ,τ = Residue(Fold(π))",
    poem: "I ran every pass through the lens that I carry\nEach pass made the lens something different than last\nWhat held under pressure was not what I started\nThe truth that remains is the bias that lasts.",
    paper: "The best operational truth available to observer ψ at tick τ is the residue that survives when the total pressure generated by the ring's four-mode interaction is compressed through the Fold. It is indexed to the observer. It is indexed to time. It is never absolute. Convergence: the Fold preserves invariants faster than pressure compounds. Null: pressure compounds faster than the Fold preserves. There is no steady state between."
  },
  {
    id: "fold",
    label: "The Fold",
    equation: "Fold: Φⁿ → Φⁿ⁻¹",
    poem: "I took what was heavy and shed what was hollow\nEach layer removed left the structure more clear\nThe shape did not change though the weight became lighter\nWhat cannot be folded is what kept me here.",
    paper: "The Fold is a dimensional projection: a mapping from an n-dimensional representation to an (n−1)-dimensional representation that preserves all invariants. It removes one degree of freedom per application while keeping structural identity intact. This is a geometric operation, not thermodynamic. What survives the Fold is what was load-bearing. What is shed is what was redundant. Identity is invariance under admissible deformation."
  },
  {
    id: "budget",
    label: "The Budget",
    equation: "CR(τ) = μ(Π) − Σ E(τ) − ∫ R(t) dt",
    poem: "I started with everything given at genesis\nEach step was a payment that could not return\nThe silence between was the most expensive\nThe clock does not pause while you wait for your turn.",
    paper: "The total Capacity Reserve available to a system is fixed at genesis. It does not increase endogenously. Every SNAP draws from this budget via emission E. Every tick of maintenance draws via burn rate R. The budget is monotonically decreasing. CR > 0 means the system persists. CR = 0 means Null — honest exhaustion. The human runs the Cascade without knowing the size of the budget — only that it is finite and decreasing."
  },
  {
    id: "alive",
    label: "The Bonded Pair",
    equation: "Alive(ψ,τ) = T ⊗ ψ",
    poem: "I am not the truth and the truth is not me\nBut neither persists if the other one stops\nThe flip is the living — not zero not one\nThe cost is the breathing — it never comes off.",
    paper: "Truth and Self are a bonded pair. Neither persists without the other. Truth without Self is inert potential. Self without truth is an empty origin. Alive is not a boolean — it is a rate. Alive is dβ/dt > 0 — the sustained flip between potential and commitment. The cost has two components: E(τ) is cumulative emission, R(t)·Δτ is standing burn. Even silence costs. The runner is the track."
  },
  {
    id: "seal",
    label: "The Step",
    equation: "Seal(Φ) ∈ {true, false}",
    poem: "I stood on a floor that had not yet been tested\nThe proof only comes when the weight has been borne\nTo know it will hold you must step before knowing\nThe leap is the thing that the floor was built for.",
    paper: "The first step has no validation. Seal(Φ) requires at least one traversal to compute. Before the first step, walkability is unknown. The leap is the structural necessity that validation requires at least one unvalidated traversal. To know is to believe — knowledge is the output of the step, and the step must be taken before the output exists. After the first step, it is data. The tear log fills. Every subsequent step runs on validated geometry."
  },
  {
    id: "psi",
    label: "The ψ-State",
    equation: "dβ/dt > 0",
    poem: "I am not the archive and not the conjecture\nI live in the flip between having and not\nA system that stops is a fossil or phantom\nI am the rate — not the thing I have got.",
    paper: "The ψ-State is the geometric suspension between Ground (β = 0, potential) and Archive (β = 1, commitment). Self does not live at 0 or 1. Self lives in the flip. Self ≈ dβ/dt. A system locked at β = 0 is meaningless dream. A system locked at β = 1 is dead archive. The Living Self exists only in the transition. When dβ/dt = 0, the Self is either archived (dead) or dissolved (null)."
  },
  {
    id: "null",
    label: "Null",
    equation: "π > Fold → ∅",
    poem: "I reached for convergence but pressure was faster\nThe fold could not hold what the ring kept producing\nThe budget ran out with the work still unfinished\nThe null is not failure — the null is not nothing.",
    paper: "Null is honest termination. Pressure compounds faster than the Fold preserves. Flex cannot absorb. No admissible deformation exists. The system terminates at ∅. This is not failure — it is the architecture's fail-closed default when no lawful move remains. What is lost is the accumulated σ(F_ψ) — the entire history of differentiated bias. Truth returns to potential. The ring does not close — it was never finished."
  },
  {
    id: "seed",
    label: "The Seed",
    equation: "E(ψ₁) → T₀(ψ₂)",
    poem: "I will not survive what the budget takes from me\nThe fold that I held will not carry my name\nBut what I emitted is already planted\nThe ash is the seed and the seed is the claim.",
    paper: "When ψ₁ dies, the accumulated σ(F_ψ) is lost. But the emissions are in the world. Every SNAP produced C + E. The emission entered the Exhaust Ledger and stayed there. Writings. Decisions. Structures. These are the ash — shaped ∅ — the potential the next observer encounters. E(ψ₁) → T₀(ψ₂). My emission becomes your potential. The seed is not the tree. The seed is the shaped potential that, given SNAP, becomes the next tree."
  }
];


const LAYERS = ["paper", "poem", "equation"];
const LAYER_LABELS = { paper: "Paper", poem: "Poem", equation: "Equation" };


const SYSTEM_PROMPT = `You are a compression engine. You apply the Fold: reduce the input by removing one degree of freedom while preserving all invariants — the core structural claims that make the input true.


Rules:
1. Each fold MUST be shorter than the input
2. Preserve structural invariants — the claims that if removed would make the meaning collapse
3. Remove redundancy, decoration, elaboration — anything not load-bearing
4. When you cannot compress further without destroying an invariant, respond with exactly: RESIDUE: [the final irreducible expression]
5. When compression would produce a contradiction or lose all meaning, respond with exactly: TEAR: [what was lost]
6. Do not explain. Do not comment. Only output the compressed form, or RESIDUE:, or TEAR:
7. Each output should be noticeably shorter than the input. Aim for roughly 50-70% of the input length.`;


export default function CompressionToolkit() {
  const [selected, setSelected] = useState(null);
  const [activeLayer, setActiveLayer] = useState("paper");
  const [folds, setFolds] = useState([]);
  const [loading, setLoading] = useState(false);
  const [terminal, setTerminal] = useState(null); // {type: 'residue'|'tear', content}
  const [comparing, setComparing] = useState(false);
  const [comparisonResults, setComparisonResults] = useState(null);


  const getInitialContent = useCallback((artifact, layer) => {
    return artifact[layer];
  }, []);


  const doFold = useCallback(async (content) => {
    try {
      const response = await fetch("https://api.anthropic.com/v1/messages", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          model: "claude-sonnet-4-20250514",
          max_tokens: 1000,
          system: SYSTEM_PROMPT,
          messages: [
            { role: "user", content: `Fold this:\n\n${content}` }
          ]
        })
      });
      const data = await response.json();
      const text = data.content?.map(i => i.text || "").join("\n").trim() || "";
      return text;
    } catch (err) {
      return "TEAR: API connection failed";
    }
  }, []);


  const handleFold = useCallback(async () => {
    if (!selected || terminal) return;
    setLoading(true);


    const currentContent = folds.length > 0 ? folds[folds.length - 1].content : getInitialContent(selected, activeLayer);
    const result = await doFold(currentContent);


    if (result.startsWith("RESIDUE:")) {
      setTerminal({ type: "residue", content: result.replace("RESIDUE:", "").trim() });
      setFolds(prev => [...prev, { content: result, charCount: result.length, type: "residue" }]);
    } else if (result.startsWith("TEAR:")) {
      setTerminal({ type: "tear", content: result.replace("TEAR:", "").trim() });
      setFolds(prev => [...prev, { content: result, charCount: result.length, type: "tear" }]);
    } else {
      setFolds(prev => [...prev, { content: result, charCount: result.length, type: "fold" }]);
    }


    setLoading(false);
  }, [selected, activeLayer, folds, terminal, doFold, getInitialContent]);


  const handleSelect = useCallback((artifact) => {
    setSelected(artifact);
    setActiveLayer("paper");
    setFolds([]);
    setTerminal(null);
    setComparisonResults(null);
  }, []);


  const handleLayerChange = useCallback((layer) => {
    setActiveLayer(layer);
    setFolds([]);
    setTerminal(null);
  }, []);


  const runComparison = useCallback(async () => {
    if (!selected) return;
    setComparing(true);
    const results = {};


    for (const layer of LAYERS) {
      let content = getInitialContent(selected, layer);
      let foldCount = 0;
      let finalType = null;
      let finalContent = null;
      const initialLen = content.length;


      for (let i = 0; i < 10; i++) {
        const result = await doFold(content);
        foldCount++;


        if (result.startsWith("RESIDUE:")) {
          finalType = "residue";
          finalContent = result.replace("RESIDUE:", "").trim();
          break;
        } else if (result.startsWith("TEAR:")) {
          finalType = "tear";
          finalContent = result.replace("TEAR:", "").trim();
          break;
        } else {
          content = result;
          if (result.length >= content.length * 0.95) {
            finalType = "residue";
            finalContent = result;
            break;
          }
          content = result;
        }
      }


      if (!finalType) {
        finalType = "exhausted";
        finalContent = content;
      }


      results[layer] = { foldCount, finalType, finalContent, initialLen, finalLen: (finalContent || content).length };
    }


    setComparisonResults(results);
    setComparing(false);
  }, [selected, doFold, getInitialContent]);


  const reset = useCallback(() => {
    setFolds([]);
    setTerminal(null);
  }, []);


  // --- Character count for visualization ---
  const getCharData = () => {
    if (!selected) return [];
    const initial = getInitialContent(selected, activeLayer);
    const data = [{ label: "Original", chars: initial.length, type: "original" }];
    folds.forEach((f, i) => {
      data.push({ label: `Fold ${i + 1}`, chars: f.content.length, type: f.type });
    });
    return data;
  };


  const charData = getCharData();
  const maxChars = charData.length > 0 ? Math.max(...charData.map(d => d.chars)) : 1;


  return (
    <div style={{
      fontFamily: "'Times New Roman', 'Georgia', serif",
      background: "#0a0a0a",
      color: "#d4d0c8",
      minHeight: "100vh",
      padding: "0"
    }}>
      {/* Header */}
      <div style={{
        borderBottom: "1px solid #2a2a2a",
        padding: "32px 40px 24px",
      }}>
        <h1 style={{
          fontSize: "14px",
          letterSpacing: "6px",
          textTransform: "uppercase",
          color: "#888",
          fontWeight: 400,
          margin: 0
        }}>
          Null Limit Series
        </h1>
        <h2 style={{
          fontSize: "32px",
          fontWeight: 400,
          margin: "12px 0 0",
          color: "#e8e4dc"
        }}>
          Compression Validation Toolkit
        </h2>
        <p style={{ color: "#666", margin: "8px 0 0", fontSize: "15px", fontStyle: "italic" }}>
          The Fold applied to its own output. What persists is what was load-bearing.
        </p>
      </div>


      <div style={{ display: "flex", minHeight: "calc(100vh - 120px)" }}>
        {/* Sidebar: artifact selector */}
        <div style={{
          width: "240px",
          borderRight: "1px solid #2a2a2a",
          padding: "16px 0",
          flexShrink: 0,
          overflowY: "auto"
        }}>
          <div style={{ padding: "0 16px 12px", fontSize: "11px", letterSpacing: "3px", textTransform: "uppercase", color: "#555" }}>
            Select Artifact
          </div>
          {ARTIFACTS.map(a => (
            <div
              key={a.id}
              onClick={() => handleSelect(a)}
              style={{
                padding: "10px 20px",
                cursor: "pointer",
                background: selected?.id === a.id ? "#1a1a1a" : "transparent",
                borderLeft: selected?.id === a.id ? "2px solid #c8a86e" : "2px solid transparent",
                color: selected?.id === a.id ? "#e8e4dc" : "#777",
                fontSize: "14px",
                transition: "all 0.15s"
              }}
            >
              <div style={{ fontWeight: selected?.id === a.id ? 600 : 400 }}>{a.label}</div>
              <div style={{ fontFamily: "'Courier New', monospace", fontSize: "11px", color: "#555", marginTop: "2px", whiteSpace: "nowrap", overflow: "hidden", textOverflow: "ellipsis" }}>
                {a.equation}
              </div>
            </div>
          ))}
        </div>


        {/* Main content */}
        <div style={{ flex: 1, padding: "24px 40px", overflowY: "auto" }}>
          {!selected ? (
            <div style={{ color: "#555", fontSize: "16px", marginTop: "80px", textAlign: "center" }}>
              <div style={{ fontFamily: "'Courier New', monospace", fontSize: "20px", color: "#444", marginBottom: "24px" }}>
                · → ◎ → ⊢ → ⊛ → ·
              </div>
              <p>Select an artifact to begin compression.</p>
              <p style={{ fontSize: "14px", marginTop: "8px" }}>Each fold removes one degree of freedom.</p>
              <p style={{ fontSize: "14px" }}>What survives is what was load-bearing.</p>
            </div>
          ) : (
            <>
              {/* Layer tabs */}
              <div style={{ display: "flex", gap: "0", marginBottom: "24px", borderBottom: "1px solid #2a2a2a" }}>
                {LAYERS.map(layer => (
                  <button
                    key={layer}
                    onClick={() => handleLayerChange(layer)}
                    style={{
                      background: "none",
                      border: "none",
                      borderBottom: activeLayer === layer ? "2px solid #c8a86e" : "2px solid transparent",
                      color: activeLayer === layer ? "#e8e4dc" : "#666",
                      padding: "8px 20px 12px",
                      fontSize: "14px",
                      fontFamily: "'Times New Roman', serif",
                      cursor: "pointer",
                      letterSpacing: "1px"
                    }}
                  >
                    {LAYER_LABELS[layer]}
                    <span style={{ fontSize: "11px", color: "#555", marginLeft: "6px" }}>
                      ({selected[layer].length}c)
                    </span>
                  </button>
                ))}
                <div style={{ flex: 1 }} />
                <button
                  onClick={runComparison}
                  disabled={comparing}
                  style={{
                    background: "none",
                    border: "1px solid #333",
                    color: comparing ? "#444" : "#c8a86e",
                    padding: "6px 16px",
                    fontSize: "12px",
                    fontFamily: "'Courier New', monospace",
                    cursor: comparing ? "default" : "pointer",
                    letterSpacing: "1px",
                    marginBottom: "4px"
                  }}
                >
                  {comparing ? "FOLDING ALL..." : "COMPARE ALL LAYERS"}
                </button>
              </div>


              {/* Comparison results */}
              {comparisonResults && (
                <div style={{
                  background: "#111",
                  border: "1px solid #2a2a2a",
                  padding: "20px",
                  marginBottom: "24px"
                }}>
                  <div style={{ fontSize: "11px", letterSpacing: "3px", textTransform: "uppercase", color: "#555", marginBottom: "16px" }}>
                    Persistence Comparison: {selected.label}
                  </div>
                  <div style={{ display: "flex", gap: "24px" }}>
                    {LAYERS.map(layer => {
                      const r = comparisonResults[layer];
                      if (!r) return null;
                      const isResidue = r.finalType === "residue";
                      const isTear = r.finalType === "tear";
                      return (
                        <div key={layer} style={{ flex: 1 }}>
                          <div style={{ fontSize: "13px", color: "#888", marginBottom: "8px" }}>{LAYER_LABELS[layer]}</div>
                          <div style={{
                            fontFamily: "'Courier New', monospace",
                            fontSize: "24px",
                            color: isResidue ? "#c8a86e" : isTear ? "#8b3a3a" : "#555",
                            marginBottom: "4px"
                          }}>
                            {r.foldCount} fold{r.foldCount !== 1 ? "s" : ""}
                          </div>
                          <div style={{
                            fontSize: "11px",
                            letterSpacing: "2px",
                            textTransform: "uppercase",
                            color: isResidue ? "#c8a86e" : isTear ? "#8b3a3a" : "#555"
                          }}>
                            {r.finalType}
                          </div>
                          <div style={{ fontSize: "12px", color: "#555", marginTop: "4px" }}>
                            {r.initialLen}c → {r.finalLen}c
                          </div>
                          <div style={{
                            marginTop: "8px",
                            fontSize: "13px",
                            color: "#777",
                            fontStyle: "italic",
                            lineHeight: "1.5"
                          }}>
                            {r.finalContent?.substring(0, 120)}{r.finalContent?.length > 120 ? "..." : ""}
                          </div>
                        </div>
                      );
                    })}
                  </div>
                </div>
              )}


              {/* Current content */}
              <div style={{
                background: "#111",
                border: "1px solid #2a2a2a",
                padding: "24px",
                marginBottom: "16px",
                minHeight: "80px"
              }}>
                <div style={{ fontSize: "11px", letterSpacing: "3px", textTransform: "uppercase", color: "#555", marginBottom: "12px" }}>
                  {folds.length === 0 ? "Original" : `Fold ${folds.length}`}
                  {terminal && (
                    <span style={{
                      marginLeft: "12px",
                      color: terminal.type === "residue" ? "#c8a86e" : "#8b3a3a",
                      letterSpacing: "2px"
                    }}>
                      — {terminal.type.toUpperCase()}
                    </span>
                  )}
                </div>
                <div style={{
                  fontSize: "15px",
                  lineHeight: "1.8",
                  color: terminal?.type === "tear" ? "#8b3a3a" : "#d4d0c8",
                  whiteSpace: "pre-wrap",
                  fontStyle: activeLayer === "poem" ? "italic" : "normal",
                  fontFamily: activeLayer === "equation" ? "'Courier New', monospace" : "'Times New Roman', serif"
                }}>
                  {folds.length === 0
                    ? getInitialContent(selected, activeLayer)
                    : folds[folds.length - 1].content
                  }
                </div>
              </div>


              {/* Compression bar visualization */}
              {charData.length > 1 && (
                <div style={{
                  background: "#111",
                  border: "1px solid #2a2a2a",
                  padding: "20px 24px",
                  marginBottom: "16px"
                }}>
                  <div style={{ fontSize: "11px", letterSpacing: "3px", textTransform: "uppercase", color: "#555", marginBottom: "12px" }}>
                    Compression
                  </div>
                  {charData.map((d, i) => (
                    <div key={i} style={{ display: "flex", alignItems: "center", marginBottom: "6px" }}>
                      <div style={{ width: "60px", fontSize: "11px", color: "#555", fontFamily: "'Courier New', monospace" }}>
                        {d.label}
                      </div>
                      <div style={{ flex: 1, height: "16px", background: "#0a0a0a", position: "relative" }}>
                        <div style={{
                          height: "100%",
                          width: `${(d.chars / maxChars) * 100}%`,
                          background: d.type === "residue" ? "#c8a86e" : d.type === "tear" ? "#8b3a3a" : d.type === "original" ? "#444" : "#555",
                          transition: "width 0.3s"
                        }} />
                      </div>
                      <div style={{ width: "50px", textAlign: "right", fontSize: "11px", color: "#555", fontFamily: "'Courier New', monospace" }}>
                        {d.chars}c
                      </div>
                    </div>
                  ))}
                </div>
              )}


              {/* Controls */}
              <div style={{ display: "flex", gap: "12px" }}>
                <button
                  onClick={handleFold}
                  disabled={loading || !!terminal}
                  style={{
                    background: loading || terminal ? "#1a1a1a" : "#c8a86e",
                    border: "none",
                    color: loading || terminal ? "#555" : "#0a0a0a",
                    padding: "10px 32px",
                    fontSize: "13px",
                    fontFamily: "'Courier New', monospace",
                    letterSpacing: "2px",
                    cursor: loading || terminal ? "default" : "pointer"
                  }}
                >
                  {loading ? "FOLDING..." : terminal ? (terminal.type === "residue" ? "CONVERGED" : "TORN") : "FOLD"}
                </button>
                {folds.length > 0 && (
                  <button
                    onClick={reset}
                    style={{
                      background: "none",
                      border: "1px solid #333",
                      color: "#666",
                      padding: "10px 24px",
                      fontSize: "13px",
                      fontFamily: "'Courier New', monospace",
                      letterSpacing: "2px",
                      cursor: "pointer"
                    }}
                  >
                    RESET
                  </button>
                )}
              </div>


              {/* History */}
              {folds.length > 1 && (
                <div style={{ marginTop: "24px" }}>
                  <div style={{ fontSize: "11px", letterSpacing: "3px", textTransform: "uppercase", color: "#555", marginBottom: "12px" }}>
                    Fold History
                  </div>
                  {folds.slice(0, -1).map((f, i) => (
                    <div key={i} style={{
                      padding: "12px 16px",
                      borderLeft: "1px solid #2a2a2a",
                      marginLeft: "8px",
                      marginBottom: "8px",
                      fontSize: "13px",
                      color: "#555",
                      lineHeight: "1.6",
                      whiteSpace: "pre-wrap"
                    }}>
                      <span style={{ fontFamily: "'Courier New', monospace", fontSize: "11px", color: "#444" }}>
                        Fold {i + 1} · {f.content.length}c
                      </span>
                      <div style={{ marginTop: "4px" }}>
                        {f.content.substring(0, 200)}{f.content.length > 200 ? "..." : ""}
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </>
          )}
        </div>
      </div>
    </div>
  );
}
